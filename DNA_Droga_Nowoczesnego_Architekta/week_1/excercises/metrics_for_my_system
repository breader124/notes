Drivery architektoniczne w systemie, nad którym pracuję pod kątem:
  - wymagań funkcjonalnych:
    - istnienie wielu niezależnych funkcjonalności -> podział każdej implementowanej funkcjonalności na 
      osobne serwlety oraz moduły EJB (zapewnia nam to niezależność kodu oraz niezależność wdrożeń, 
      zmniejsza również konieczność przeprowadzania bardzo częstych, a co za tym idzie 
      drogich, testów regresyjnych)
    - obsługa kilku języków -> stworzenie plików properties dla każdej wersji językowej, piszemy kod
      zależny od etykiet, a nie zduplikowany, zawierający zahardkodowane Stringi
  - atrybutów jakościowych:
    - bardzo wysoka dostępność -> wykorzystanie starej, sprawdzonej technologii (zapewnia nam obserwowaną
      od lat niemalże 100% dostępność, która jest bardzo ważna dla naszych klientów)
    - konieczność przeprowadzenia audytu -> używany customowego sposobu logowanie opracowanego wewnątrz firmy
      (pozwala ona na przeprowadzenie audytów ze stron instytucji zajmujących się środkami finansowymi)
  - ograniczeń projektowych:
    - zbyt mały budżet -> pozostanie przy starej technologii (z uwagi na ograniczony budżet nie możemy
      przetestować innej i zmigrować)
    - konieczność komunikacji z MF, aby wywołać logikę biznesową -> podziele projektu na dwie wspomniane
      wcześniej warstwy: serwlety i EJB (uzyskujemy wtedy jasno podzielone rozwiązanie, gdzie moduły 
      odpowiedzialne za komunikację z MF nie są zależne od naszych serwletów)
  - konwencje:
    - używamy naszego własnego, customowego frameworka -> pozostanie przy nim i podążanie za narzucanymi
      przez niego zasadami, ma to wpływ na inne drivery architektoniczne 
    - sposób wdrożenia wykorzystywany przez inne podobne projekty -> budujemy monolityczną aplikację, która
      współdzieli część kodu z innymi monolitycznymi aplikacjami

Metryki dla obecnego systemu:
  - procent kodu wspólnych feature'ów współdzielonego z innymi projektami (metryka jakościowa):
    - opis: zależy nam na uwspólnieniu jak największej części kodu z innymi projektami, nie chcemy pisać
      kilkukrotnie tego samego, jest to nieefektywne i prowadzi do przepalania pieniędzy
    - poziomy:
      - current: 50%
      - limit: 60% -> poniżej tego poziomu będziemy marnować tyle czasu na powielanie kodu, że nie będziemy 
        mieć czasu na implementację tego, czego faktycznie chcą nasi stakeholderzy
      - goal: 80%
      - wish: 95%
  - czas kompilacji na Hudsonie (metryka łączona):
    - opis: zależy nam na maksymalnym skróceniu czasu kompilacji, ponieważ każda prośba o extra deploy 
      zajmuje zbyt dużo czasu do ostatecznego ukończenia
    - poziomy:
      - current: 1h 10m
      - goal: 30m -> chcemy skrócić ten czas, a następnie utrzymać go na tym poziomie, ponieważ znacznie 
        poprawi to komfort każdego kolejnego deploymentu
      - wish: 10m -> zgodnie z zasadą mówiącą, że kompilacja nie powinna zajmować więcej niż 10 minut
  - dostępność naszego rozwiązania (metryka dłużna):
    - opis: zależy nam na zapewnieniu dostępności poszczególnych modułów zgodnie z SLA, nie możemy wyjść
      poza te ramy
    - poziomy:
      - current: system jest niedostępny pomiędzy 3 a 4 w nocy, kiedy trwa deployment
      - goal: system może być niedostępny pomiędzy 3 a 5 w nocy, ponieważ tak głosi umowa z bankiem, jest to
        poziom SLA-3
