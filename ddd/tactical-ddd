value object -- object which value is in importance
entity object -- object which identity is in importance

aggregates: aggregate is a group of entities and value objects that have certain characteristics:
	- aggregate is created, retrieved and stored as a whole
	- aggregate is always in a consistent state
	- aggregate is owned by an entity called the aggregate root, whose ID is used to identify the aggregate itself
	- aggregate can be referenced from the outside through its root only
	- aggregate root is responsible for enforcing business invariants inside the aggregate, keeping consistent state all the time

aggregate design guidelines:
	- keep your aggregates small
	- refer to other aggregates by ID
	- change one aggregate per transaction
	- use optimistic locking

domain events characteristics:
	- they are immutable
	- they have timestamps when the event in question occurred
	- they may have a unique Id that helps to distinguish one event from another
	- they are published by aggregate roots or domain services

types of objects:
	- movable -> there can be one more that one instance of this object's class and it can be passed around
	- static -> there cannot be more than one instance of this object's class, there can't be any references from movable objects to static objects, if there is need to use static object from movable object's context, there is need to pass static object as a method argument

movable objects hierarchy: movable-types-hierarchy.png

static objects:
	- repositories -> capability to save an aggregate in its entirety in some kind of storage, capability to retrieve an aggregate in its entirety in some kind of storage, capability to delete an aggregate in its entirety in some kind of storage
	- domain services -> stateless, highly cohesive (OBEY THE SRP), contains business logic that doesn't fit elsewhere, can interact with repositories and with themselves, can publish domain events
	- factories -> business logic is involved in creation of aggregates, structure and the content of aggregate may be very different depending on the input, input data is so extensive that the builder pattern is needed, factory is translating from one bounded context to another; factory can be a static factory method in the aggregate class or a separate factory class, factories may interact with other factories, services or repositories (but can't change the state of the database! no update, save or delete is allowed) 
